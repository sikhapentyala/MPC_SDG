from Compiler import ml, util, mpc_math, library
import os


# np.random.choice()
def random_choice(prob):
      c = sfix.Array(num_candidates)
      sum_p = sfix(0)
      for i in range(num_candidates):
          sum_p = sum_p + prob[i]
          c[i] = sum_p

      rnd = sfix.get_random(0, 1)
      t = sum_p * rnd
      s = 0
      for i in range(num_candidates):
          cnd = (c[i] > t)
          s = s + cnd
      cnd = (s == 0)
      key = (num_candidates-cnd) - s * (1 - cnd)
      return key


# compute workload answers not already computed
def compute_workload_answers():
    for idx in private_ids:
        # fetching cols
        column1 = columns_private_ids[idx][0]
        column2 = columns_private_ids[idx][1]
        alice_col =   alice_data.get_vector_by_indices(None, column1)
        bob_col =   bob_data.get_vector_by_indices(None, column2)

        # setting cube
        domain_info = domain_bins_private_ids[idx]
        D1_ = domain_info[0]
        D2_ = domain_info[1]
        D1 = [i for i in range(D1_)]
        D2 = [i for i in range(D2_)]
        # computing 2way marginal
        #marginal = sint.Matrix(len(D1),len(D2))
        for i in range(N):
            x_ = alice_col[i]
            y_ = bob_col[i]
            for j in range(len(D1)):
                for k in range(len(D2)):
                    m = (x_ == D1[j]) * (y_ == D2[k])
                    ans[idx][j*len(D2) + k] += m
    return ans

# Sampling Gaussian with Irwin-Hall
def NormalSampler():
   sum_u = 0
   for _ in range(12):
        sum_u = sum_u + sfix.get_random(0, 1)
   sum_u = sum_u - 6
   return sum_u

# Computing Noise vector
def compute_guassian(scale, size):
    noise = sfix.Array(max_domain_size)
    @for_range_opt(size)
    def _(i):
       noise[i] = scale * NormalSampler()
    return noise


# Compute L1 norm
def compute_l1_norm(err, size):
    sum = sfix(0)
    err = Array.create_from(err)
    @for_range(size)
    def _(i):
        sum.update(sum + mpc_math.abs_fx(err[i]))
    return sum

# Get noisy answers
def get_noisy_measurement(index, scale):
    size = domain[index]
    x = alice_ans[index] + bob_ans[index]
    noise = compute_guassian(scale,size)
    return x + noise



# Select worst approximated
def select_marginal_worst_approximated(candidate_ids, epsilon, max_sensitivity, bias, wgt):
    errors = sfix.Array(num_candidates)
    for i in range(num_candidates):
        idx = candidate_ids[i]
        size_ = domain[idx]
        bias_ = bias[idx]
        wt_ = wgt[idx]
        x = alice_ans[idx] + bob_ans[idx]
        x_est = est_ans[idx]
        err_ = x - x_est
        err = wt_ * (compute_l1_norm(err_, size_) - bias_)
        errors[i] = err
    error_max = util.max(errors)
    prob = ml.softmax(0.5*epsilon/max_sensitivity*(errors - error_max))
    ax = random_choice(prob)
    return ax





max_domain_size = int(program.args[1])
num_workloads = int(program.args[2])
num_candidates = int(program.args[2])
N = int(program.args[3])
num_f1 = int(program.args[4])
num_f2 = int(program.args[5])

alice_ans = sfix.Matrix(num_workloads, max_domain_size)
bob_ans = sfix.Matrix(num_workloads, max_domain_size)
est_ans = sfix.Matrix(num_workloads, max_domain_size)

alice_data = sfix.Matrix(N, num_f1)
bob_data = sfix.Matrix(N, num_f2)

bob_data.input_from(1)
bob_ans.input_from(1)

alice_data.input_from(0)
alice_ans.input_from(0)
est_ans.input_from(0)

total_data = sfix.Matrix(N, num_f1+num_f2)

# Total dataset
for i in range(N):
   for j in range(num_f1):
        total_data[i][j] = alice_data[i][j]
for i in range(N):
   for j in range(num_f2):
        total_data[i][num_f1+j] = bob_data[i][j]

private_ids =  [0, 1, 2, 3, 4, 5, 13, 14, 15, 16, 17, 25, 26, 27, 28, 36, 37, 38, 46, 47, 55, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90]

columns_private_ids =  [[0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7], [0, 8], [0, 9], [0, 10], [0, 11], [0, 12], [0, 13], [1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [1, 7], [1, 8], [1, 9], [1, 10], [1, 11], [1, 12], [1, 13], [2, 3], [2, 4], [2, 5], [2, 6], [2, 7], [2, 8], [2, 9], [2, 10], [2, 11], [2, 12], [2, 13], [3, 4], [3, 5], [3, 6], [3, 7], [3, 8], [3, 9], [3, 10], [3, 11], [3, 12], [3, 13], [4, 5], [4, 6], [4, 7], [4, 8], [4, 9], [4, 10], [4, 11], [4, 12], [4, 13], [5, 6], [5, 7], [5, 8], [5, 9], [5, 10], [5, 11], [5, 12], [5, 13], [6, 7], [6, 8], [6, 9], [6, 10], [6, 11], [6, 12], [6, 13], [7, 8], [7, 9], [7, 10], [7, 11], [7, 12], [7, 13], [8, 9], [8, 10], [8, 11], [8, 12], [8, 13], [9, 10], [9, 11], [9, 12], [9, 13], [10, 11], [10, 12], [10, 13], [11, 12], [11, 13], [12, 13]]

domain_bins_private_ids = [[85, 9], [85, 100], [85, 16], [85, 7], [85, 15], [85, 6], [85, 5], [85, 2], [85, 100], [85, 100], [85, 99], [85, 42], [85, 2], [9, 100], [9, 16], [9, 7], [9, 15], [9, 6], [9, 5], [9, 2], [9, 100], [9, 100], [9, 99], [9, 42], [9, 2], [100, 16], [100, 7], [100, 15], [100, 6], [100, 5], [100, 2], [100, 100], [100, 100], [100, 99], [100, 42], [100, 2], [16, 7], [16, 15], [16, 6], [16, 5], [16, 2], [16, 100], [16, 100], [16, 99], [16, 42], [16, 2], [7, 15], [7, 6], [7, 5], [7, 2], [7, 100], [7, 100], [7, 99], [7, 42], [7, 2], [15, 6], [15, 5], [15, 2], [15, 100], [15, 100], [15, 99], [15, 42], [15, 2], [6, 5], [6, 2], [6, 100], [6, 100], [6, 99], [6, 42], [6, 2], [5, 2], [5, 100], [5, 100], [5, 99], [5, 42], [5, 2], [2, 100], [2, 100], [2, 99], [2, 42], [2, 2], [100, 100], [100, 99], [100, 42], [100, 2], [100, 99], [100, 42], [100, 2], [99, 42], [99, 2], [42, 2]]


# Compute workload answers
ans = alice_ans + bob_ans


x = compute_workload_answers()

epsilon = cfix._new(public_input())
max_sensitivity = cfix._new(public_input())
scale = cfix._new(public_input())

candidate_ids = Array(num_candidates, cint)
for i in range(num_candidates):
    candidate_ids[i] = public_input()

domain = Array(num_workloads, cint)
for i in range(num_workloads):
    domain[i] = public_input()

bias = Array(num_candidates, cint)
for i in range(num_candidates):
    bias[i] = public_input()

wgt = Array(num_candidates, cint)
for i in range(num_candidates):
    wgt[i] = public_input()

start_timer(100)
ax = select_marginal_worst_approximated(candidate_ids, epsilon, max_sensitivity,bias,wgt)
y = get_noisy_measurement(ax.reveal(), scale)
stop_timer(100)

print_ln("Ax:%s", ax.reveal())
print_ln("Y:%s", y.reveal())











