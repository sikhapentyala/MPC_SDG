from Compiler import ml, util, mpc_math, library
import os
program.use_split(3)

# np.random.choice()
def random_choice(prob):
      c = sfix.Array(num_candidates)
      sum_p = sfix(0)
      for i in range(num_candidates):
          sum_p = sum_p + prob[i]
          c[i] = sum_p

      rnd = sfix.get_random(0, 1)
      t = sum_p * rnd
      s = 0
      for i in range(num_candidates):
          cnd = (c[i] > t)
          s = s + cnd
      cnd = (s == 0)
      key = (num_candidates-cnd) - s * (1 - cnd)
      return key
# compute workload answers not already computed
def compute_workload_answers():
    for idx in private_ids:
        # fetching cols
        column1 = columns_private_ids[idx][0]
        column2 = columns_private_ids[idx][1]
        alice_col =   alice_data.get_vector_by_indices(None, column1)
        bob_col =   bob_data.get_vector_by_indices(None, column2)

        # setting cube
        domain_info = domain_bins_private_ids[idx]
        D1_ = domain_info[0]
        D2_ = domain_info[1]
        D1 = [i for i in range(D1_)]
        D2 = [i for i in range(D2_)]
        # computing 2way marginal
        #marginal = sint.Matrix(len(D1),len(D2))
        for i in range(N):
        #def _(i):
            x_ = alice_col[i]
            y_ = bob_col[i]
            for j in range(len(D1)):
            #def _(j):
                for k in range(len(D2)):
                #def _(k):
                    m = (x_ == D1[j]) * (y_ == D2[k])
                    ans[idx][j*len(D2) + k] += m
    return ans
'''
# compute workload answers not already computed
def compute_workload_answers():
    for idx in private_ids:
        # fetching cols
        column1 = columns_private_ids[idx][0]
        column2 = columns_private_ids[idx][1]
        alice_col =   alice_data.get_vector_by_indices(None, column1)
        bob_col =   bob_data.get_vector_by_indices(None, column2)

        # setting cube
        domain_info = domain_bins_private_ids[idx]
        D1_ = domain_info[0]
        D2_ = domain_info[1]
        D1 = [i for i in range(D1_)]
        D2 = [i for i in range(D2_)]
        # computing 2way marginal
        #marginal = sint.Matrix(len(D1),len(D2))
        for i in range(N):
            x_ = alice_col[i]
            y_ = bob_col[i]
            for j in range(len(D1)):
                for k in range(len(D2)):
                    m = (x_ == D1[j]) * (y_ == D2[k])
                    ans[idx][j*len(D2) + k] += m
    return ans
'''
# Sampling Gaussian with Irwin-Hall
def NormalSampler():
   sum_u = 0
   for _ in range(12):
        sum_u = sum_u + sfix.get_random(0, 1)
   sum_u = sum_u - 6
   return sum_u

# Computing Noise vector
def compute_guassian(scale, size):
    noise = sfix.Array(max_domain_size)
    @for_range_opt(size)
    def _(i):
       noise[i] = scale * NormalSampler()
    return noise


# Compute L1 norm
def compute_l1_norm(err, size):
    sum = sfix(0)
    err = Array.create_from(err)
    @for_range(size)
    def _(i):
        sum.update(sum + mpc_math.abs_fx(err[i]))
    return sum

# Get noisy answers
def get_noisy_measurement(index, scale):
    size = domain[index]
    x = alice_ans[index] + bob_ans[index]
    noise = compute_guassian(scale,size)
    return x + noise



# Select worst approximated
def select_marginal_worst_approximated(candidate_ids, epsilon, max_sensitivity, bias, wgt):
    errors = sfix.Array(num_candidates)
    for i in range(num_candidates):
        idx = candidate_ids[i]
        size_ = domain[idx]
        bias_ = bias[idx]
        wt_ = wgt[idx]
        x = alice_ans[idx] + bob_ans[idx]
        x_est = est_ans[idx]
        err_ = x - x_est
        err = wt_ * (compute_l1_norm(err_, size_) - bias_)
        errors[i] = err
    error_max = util.max(errors)
    prob = ml.softmax(0.5*epsilon/max_sensitivity*(errors - error_max))
    ax = random_choice(prob)
    return ax





max_domain_size = int(program.args[1])
num_workloads = int(program.args[2])
num_candidates = int(program.args[2])
N = int(program.args[3])
num_f1 = int(program.args[4])
num_f2 = int(program.args[5])
#num_listids = int(program.args[6])


private_ids = []
#for i in range(num_listids):
#   private_ids.append(int(program.args[7+i]))


#print_ln("%s", private_ids)



alice_ans = sfix.Matrix(num_workloads, max_domain_size)
bob_ans = sfix.Matrix(num_workloads, max_domain_size)
est_ans = sfix.Matrix(num_workloads, max_domain_size)

alice_data = sfix.Matrix(N, num_f1)
bob_data = sfix.Matrix(N, num_f2)

bob_data.input_from(1)
bob_ans.input_from(1)

alice_data.input_from(0)
alice_ans.input_from(0)
est_ans.input_from(0)

total_data = sfix.Matrix(N, num_f1+num_f2)

# Total dataset
for i in range(N):
   for j in range(num_f1):
        total_data[i][j] = alice_data[i][j]
for i in range(N):
   for j in range(num_f2):
        total_data[i][num_f1+j] = bob_data[i][j]

private_ids =[32, 34, 35, 37, 39, 9, 10, 11, 41, 13, 42, 15, 44, 19, 21, 23, 25, 27, 29, 30]
#[10, 11, 12, 17, 21, 22, 23, 24, 26, 28, 29, 30, 31, 33, 34, 35, 36, 37, 39, 43, 47, 50, 52, 54] 

columns_private_ids = [[9], [3], [5], [4], [7], [1], [10], [2], [8], [3, 9], [5, 9], [4, 9], [7, 9], [1, 9], [10, 9], [2, 9], [9, 8], [3, 5], [4, 3], [7, 3], [1, 3], [10, 3], [2, 3], [3, 8], [4, 5], [7, 5], [1, 5], [10, 5], [2, 5], [5, 8], [7, 4], [1, 4], [10, 4], [2, 4], [4, 8], [7, 1], [7, 10], [7, 2], [7, 8], [1, 10], [1, 2], [1, 8], [10, 2], [10, 8], [2, 8]]
#[[7], [4], [5], [2], [12], [9], [11], [10], [3], [8], [7, 4], [7, 5], [2, 7], [7, 12], [7, 9], [7, 11], [7, 10], [7, 3], [7, 8], [4, 5], [2, 4], [12, 4], [9, 4], [4, 11], [10, 4], [3, 4], [8, 4], [2, 5], [12, 5], [9, 5], [5, 11], [10, 5], [3, 5], [8, 5], [2, 12], [2, 9], [2, 11], [2, 10], [2, 3], [2, 8], [9, 12], [12, 11], [10, 12], [3, 12], [8, 12], [9, 11], [10, 9], [9, 3], [8, 9], [10, 11], [3, 11], [8, 11], [10, 3], [10, 8], [8, 3]]

domain_bins_private_ids =[[2], [3], [2], [3], [3], [3], [3], [3], [2], [3, 2], [2, 2], [3, 2], [3, 2], [3, 2], [3, 2], [3, 2], [2, 2], [3, 2], [3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 2], [3, 2], [3, 2], [3, 2], [3, 2], [3, 2], [2, 2], [3, 3], [3, 3], [3, 3], [3, 3], [3, 2], [3, 3], [3, 3], [3, 3], [3, 2], [3, 3], [3, 3], [3, 2], [3, 3], [3, 2], [3, 2]]
# [[6], [2], [6], [2], [3], [7], [2], [3], [3], [11], [6, 2], [6, 6], [2, 6], [6, 3], [6, 7], [6, 2], [6, 3], [6, 3], [6, 11], [2, 6], [2, 2], [3, 2], [7, 2], [2, 2], [3, 2], [3, 2], [11, 2], [2, 6], [3, 6], [7, 6], [6, 2], [3, 6], [3, 6], [11, 6], [2, 3], [2, 7], [2, 2], [2, 3], [2, 3], [2, 11], [7, 3], [3, 2], [3, 3], [3, 3], [11, 3], [7, 2], [3, 7], [7, 3], [11, 7], [3, 2], [3, 2], [11, 2], [3, 3], [3, 11], [11, 3]]


# Compute workload answers
ans = alice_ans + bob_ans

start_timer(200)
x = compute_workload_answers()
stop_timer(200)
epsilon = cfix._new(public_input())
max_sensitivity = cfix._new(public_input())
scale = cfix._new(public_input())

candidate_ids = Array(num_candidates, cint)
for i in range(num_candidates):
    candidate_ids[i] = public_input()

domain = Array(num_workloads, cint)
for i in range(num_workloads):
    domain[i] = public_input()

bias = Array(num_candidates, cint)
for i in range(num_candidates):
    bias[i] = public_input()

wgt = Array(num_candidates, cint)
for i in range(num_candidates):
    wgt[i] = public_input()

start_timer(100)
start_timer(104)
ax = select_marginal_worst_approximated(candidate_ids, epsilon, max_sensitivity,bias,wgt)
stop_timer(104)
start_timer(105)
y = get_noisy_measurement(ax.reveal(), scale)
stop_timer(105)
stop_timer(100)

print_ln("Ax:%s", ax.reveal())
print_ln("Y:%s", y.reveal())












