from Compiler import ml, util, mpc_math, library
import os


# np.random.choice()
def random_choice(prob):
      c = sfix.Array(num_candidates)
      sum_p = sfix(0)
      for i in range(num_candidates):
          sum_p = sum_p + prob[i]
          c[i] = sum_p

      rnd = sfix.get_random(0, 1)
      t = sum_p * rnd
      s = 0
      for i in range(num_candidates):
          cnd = (c[i] > t)
          s = s + cnd
      cnd = (s == 0)
      key = (num_candidates-cnd) - s * (1 - cnd)
      return key

# compute workload answers not already computed
def compute_workload_answers():
    for idx in private_ids:
        # fetching cols
        column1 = columns_private_ids[idx][0]
        column2 = columns_private_ids[idx][1]
        alice_col =   alice_data.get_vector_by_indices(None, column1)
        bob_col =   bob_data.get_vector_by_indices(None, column2)

        # setting cube
        domain_info = domain_bins_private_ids[idx]
        D1_ = domain_info[0]
        D2_ = domain_info[1]
        D1 = [i for i in range(D1_)]
        D2 = [i for i in range(D2_)]
        # computing 2way marginal
        #marginal = sint.Matrix(len(D1),len(D2))
        for i in range(N):
        #def _(i):
            x_ = alice_col[i]
            y_ = bob_col[i]
            for j in range(len(D1)):
            #def _(j):
                for k in range(len(D2)):
                #def _(k):
                    m = (x_ == D1[j]) * (y_ == D2[k])
                    ans[idx][j*len(D2) + k] += m
    return ans




# Select marginal
def select_marginal_worst_approximated(candidate_ids, epsilon):
      errors = sfix.Array(num_candidates)
      for i in range(num_candidates):
          idx = candidate_ids[i]
          size_ = domain[idx]
          x = alice_ans[idx] + bob_ans[idx]
          x_est = est_ans[idx]
          err = mpc_math.abs_fx(x - x_est)
          errors[i] = sum(err) - size_
      sensitivity = 1.0
      error_max = util.max(errors)
      prob = ml.softmax(0.5*epsilon/sensitivity*(errors - error_max))
      ax = random_choice(prob)
      return ax

# Sampling Gaussian with Irwin-Hall
def NormalSampler():
   sum_u = 0
   for _ in range(12):
        sum_u = sum_u + sfix.get_random(0, 1)
   sum_u = sum_u - 6
   return sum_u

# Computing Noise vector
def compute_guassian(scale, size):
    noise = sfix.Array(max_domain_size)
    @for_range_opt(size)
    def _(i):
       noise[i] = scale * NormalSampler()
    return noise


# Get noisy answers
def get_noisy_measurement(index, scale):
    size = domain[index]
    x = alice_ans[index] + bob_ans[index]
    noise = compute_guassian(scale,size)
    return x + noise


max_domain_size = int(program.args[1])
num_workloads = int(program.args[2])
num_candidates = int(program.args[2])
N = int(program.args[3])
num_f1 = int(program.args[4])
num_f2 = int(program.args[5])

alice_ans = sfix.Matrix(num_workloads, max_domain_size)
bob_ans = sfix.Matrix(num_workloads, max_domain_size)
est_ans = sfix.Matrix(num_workloads, max_domain_size)

alice_data = sfix.Matrix(N, num_f1)
bob_data = sfix.Matrix(N, num_f2)

bob_data.input_from(1)
bob_ans.input_from(1)

alice_data.input_from(0)
alice_ans.input_from(0)
est_ans.input_from(0)

total_data = sfix.Matrix(N, num_f1+num_f2)

# Total dataset
for i in range(N):
   for j in range(num_f1):
        total_data[i][j] = alice_data[i][j]
for i in range(N):
   for j in range(num_f2):
        total_data[i][num_f1+j] = bob_data[i][j]

private_ids = [0, 32, 2, 3, 4, 5, 33, 34, 8, 13, 14, 15, 16, 17, 18, 24, 25, 28, 29, 31]

columns_private_ids = [[7, 1], [7, 10], [7, 2], [7, 4], [7, 3], [7, 5], [7, 9], [7, 8], [1, 10], [1, 2], [1, 4], [1, 3], [1, 5], [1, 9], [1, 8], [10, 2], [10, 4], [10, 3], [10, 5], [10, 9], [10, 8], [2, 4], [2, 3], [2, 5], [2, 9], [2, 8], [4, 3], [4, 5], [4, 9], [4, 8], [3, 5], [3, 9], [3, 8], [5, 9], [5, 8], [9, 8]]
# [[2, 7], [2, 10], [2, 8], [2, 9], [2, 3], [2, 12], [2, 4], [2, 5], [2, 11], [7, 10], [7, 8], [7, 9], [7, 3], [7, 12], [7, 4], [7, 5], [7, 11], [10, 8], [10, 9], [10, 3], [10, 12], [10, 4], [10, 5], [10, 11], [8, 9], [8, 3], [8, 12], [8, 4], [8, 5], [8, 11], [9, 3], [9, 12], [9, 4], [9, 5], [9, 11], [3, 12], [3, 4], [3, 5], [3, 11], [12, 4], [12, 5], [12, 11], [4, 5], [4, 11], [5, 11]]

domain_bins_private_ids =[[3, 3], [3, 3], [3, 3], [3, 3], [3, 3], [3, 2], [3, 2], [3, 2], [3, 3], [3, 3], [3, 3], [3, 3], [3, 2], [3, 2], [3, 2], [3, 3], [3, 3], [3, 3], [3, 2], [3, 2], [3, 2], [3, 3], [3, 3], [3, 2], [3, 2], [3, 2], [3, 3], [3, 2], [3, 2], [3, 2], [3, 2], [3, 2], [3, 2], [2, 2], [2, 2], [2, 2]]
# [[2, 6], [2, 3], [2, 11], [2, 7], [2, 3], [2, 3], [2, 2], [2, 6], [2, 2], [6, 3], [6, 11], [6, 7], [6, 3], [6, 3], [6, 2], [6, 6], [6, 2], [3, 11], [3, 7], [3, 3], [3, 3], [3, 2], [3, 6], [3, 2], [11, 7], [11, 3], [11, 3], [11, 2], [11, 6], [11, 2], [7, 3], [7, 3], [7, 2], [7, 6], [7, 2], [3, 3], [3, 2], [3, 6], [3, 2], [3, 2], [3, 6], [3, 2], [2, 6], [2, 2], [6, 2]]

# Compute workload answers
ans = alice_ans + bob_ans

start_timer(200)
x = compute_workload_answers()
stop_timer(200)


# Select and measur step - same as HFL
epsilon = cfix._new(public_input())
scale = cfix._new(public_input())

candidate_ids = Array(num_candidates, cint)
for i in range(num_candidates):
    candidate_ids[i] = public_input()

domain = Array(num_workloads, cint)
for i in range(num_workloads):
    domain[i] = public_input()

start_timer(100)
start_timer(104)
ax = select_marginal_worst_approximated(candidate_ids, epsilon)
stop_timer(104)
print_ln("Ax:%s", ax.reveal())
#if ax.reveal() in private_ids:
start_timer(105)
y = get_noisy_measurement(ax.reveal(), scale)
stop_timer(105)
print_ln("Y:%s", y.reveal())
stop_timer(100)



